/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
/**
 *  Package and Import Specifications
 */
import java_cup.runtime.*;

/**
 *  Usercode Components
 */
parser code {:
    // Connect this parser to a scanner!
    Scanner s;
    Parser(Scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
scan with {: return s.next_token(); :};

/**
 *  Symbol Lists
 */

/* Terminals (tokens returned by the scanner). */
terminal            PLUS, LPAREN, RPAREN, RBRACK, COMMA, IF, ELSE, PREFIX, SUFFIX, RPAREN_LBRACK;
terminal String     STRING_LITERAL, NAME;

/*  Non terminals */
non terminal            program;
non terminal String    	exp, exptail, func_def, def_args, def_args_tail, func_content, func_call, args, args_tail, concat, concat_tail, logic_exp, cond, cond_tail, var_lit, var_lit_call;      // used to store evaluated subexpressions

/**
 *  Precedence Declarations
 */

/**
 *  The Grammar Rules
 */

program ::= exp:e {:
			System.out.println("import java.lang.Math;\n");
			System.out.println("public class Main {");
			System.out.printf("%s", e);
			// System.out.println("\tpublic static void main(String[] args) {");
			System.out.println("}");
		:}
	;

exp ::= func_def:f exp:e	{: RESULT = String.format("%s\n%s", f, e); :}
	| exptail:e				{: RESULT = String.format("%s", e); :}
	;

exptail ::= func_call:f exptail	{: RESULT = String.format("%s", f); :}
	|							{: RESULT = ""; :}
	;

func_def ::= NAME:n LPAREN def_args:a RPAREN_LBRACK func_content:c RBRACK	{: RESULT = String.format("\tpublic static String %s(%s) {\n%s\n\t}", n, a, c); :}
		;

def_args ::= NAME:n def_args_tail:t	{: RESULT = String.format("%s%s", n, t); :}
		|							{: RESULT = ""; :}
		;

def_args_tail ::= COMMA NAME:n def_args_tail:t 	{: RESULT = String.format(" ,%s%s", n, t); :}
                |								{: RESULT = ""; :}
                ;

func_content ::= func_call:s		{: RESULT = String.format("\t\t%s", s); :}
				| concat:s			{: RESULT = String.format("\t\t%s", s); :}
				| logic_exp:s		{: RESULT = String.format("\t\t%s", s); :}
				| STRING_LITERAL:s	{: RESULT = String.format("\t\treturn \"%s\";", s); :}
				;

func_call ::= NAME:n LPAREN args:a RPAREN	{: RESULT = String.format("%s(%s)", n, a); :}
			;

args ::= NAME:s args_tail:t				{: RESULT = String.format("%s%s", s, t); :}
	   | STRING_LITERAL:s args_tail:t	{: RESULT = String.format("%s%s", s, t); :}
	   | func_call:s args_tail:t		{: RESULT = String.format("%s%s", s, t); :}
	   |								{: RESULT = ""; :}
	;

args_tail ::= COMMA NAME:s args_tail:t 				{: RESULT = String.format(" ,%s%s", s, t); :}
			| COMMA STRING_LITERAL:s args_tail:t	{: RESULT = String.format(" ,%s%s", s, t); :}
			| COMMA func_call:s args_tail:t			{: RESULT = String.format(" ,%s%s", s, t); :}
			|										{: RESULT = ""; :}
			;

concat ::= NAME:n1 PLUS NAME:n2 concat_tail:t	{: RESULT = String.format("%s + %s%s", n1, n2, t); :}
		;

concat_tail ::= PLUS NAME:n	{: RESULT = String.format(" + %s", n); :}
			|				{: RESULT = ""; :}
			;

logic_exp ::= IF LPAREN cond:c RPAREN func_content:f1 ELSE func_content:f2 {: RESULT = String.format("if (%s)\n\t%s\nelse\n\t%s", c, f1, f2); :}
			;

cond ::= var_lit:n cond_tail:t	{: RESULT = String.format("%s%s", n, t); :}
	;

cond_tail ::= PREFIX var_lit_call:s	{: RESULT = String.format("prefix %s", s); :}
			| SUFFIX var_lit_call:s	{: RESULT = String.format("suffix %s", s); :}
			;

var_lit ::= NAME:n			{: RESULT = String.format("%s", n); :}
		| STRING_LITERAL:s	{: RESULT = String.format("%s", s); :}
		;

var_lit_call ::= NAME:n		{: RESULT = String.format("%s", n); :}
		| STRING_LITERAL:s	{: RESULT = String.format("%s", s); :}
		| func_call:s		{: RESULT = String.format("%s", s); :}
		;